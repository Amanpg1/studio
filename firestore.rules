rules_version = '2';

/**
 * @fileoverview Firestore Security Rules
 * @author Auto-generated by an expert Firebase Security Rules architect
 *
 * @description
 * This ruleset is designed for a health and food tracking application. It follows
 * a strict prototyping model: authorization is tightly controlled, but data schemas
 * are flexible to allow for rapid development.
 *
 * Core Philosophy:
 * The security model is primarily based on user ownership. All personal user data,
 * such as profiles and food scan histories, is strictly isolated to the authenticated
 * user who created it. This prevents any user from accessing another user's private
 * information.
 *
 * Data Structure:
 * - /users/{userId}: Contains private UserProfile documents. Access is restricted to the owner.
 * - /users/{userId}/foodScans/{foodScanId}: A subcollection storing a user's private food scan history.
 * - /healthConditions/{healthConditionId}: A top-level collection for master data on health conditions. This data is public to read.
 * - /foodPreferences/{foodPreferenceId}: A top-level collection for master data on food preferences. This data is also public to read.
 *
 * Key Security Decisions:
 * - User Privacy: Listing the top-level /users collection is explicitly forbidden to prevent enumeration of all application users.
 * - Ownership Enforcement: All personal data under /users/{userId} can only be accessed by the user whose UID matches {userId}.
 * - Public Master Data: The 'healthConditions' and 'foodPreferences' collections are publicly readable by any client, but write access is disabled. This is a common pattern for data that is managed by developers or administrators directly, not by end-users. A TODO has been added to guide future implementation of an admin role for managing this data.
 * - Denormalization for Authorization: The 'foodScans' documents contain a denormalized `userId` field. This allows security rules to validate ownership directly from the document itself, which is more efficient and secure than relying solely on the path.
 * - Relational Integrity: On creation and update, rules validate that ownership fields (like `id` in a user profile or `userId` in a food scan) are correctly set and cannot be changed, ensuring data consistency.
 *
 * Prototyping Flexibility:
 * In line with the prototyping philosophy, these rules DO NOT validate the shape or type of most data fields (e.g., `name`, `foodName`, `ingredients`). Validation is strictly limited to fields critical for authorization and relational integrity, such as ownership IDs.
 */
service cloud.firestore {
  match /databases/{database}/documents {

    // -------------------------------------------------------------------------
    // Helper Functions
    // -------------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user's UID matches the provided userId.
     * This is the primary function for enforcing data ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks for ownership on an existing document. Used for update/delete
     * to ensure the operation targets a document that actually exists.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Validates required fields for creating a UserProfile document.
     * Ensures the document's internal `id` is consistent with the user's auth UID.
     */
    function hasValidUserProfileDataOnCreate(userId) {
      let data = request.resource.data;
      return data.id == userId;
    }

    /**
     * Validates data for updating a UserProfile.
     * Enforces immutability of the critical `id` field.
     */
    function hasValidUserProfileDataOnUpdate() {
      let data = request.resource.data;
      return data.id == resource.data.id;
    }

    /**
     * Validates required fields for creating a FoodScan document.
     * Ensures the document's internal `userId` is consistent with the path.
     */
    function hasValidFoodScanDataOnCreate(userId) {
      let data = request.resource.data;
      return data.userId == userId;
    }

    /**
     * Validates data for updating a FoodScan.
     * Enforces immutability of the critical `userId` ownership field.
     */
    function hasValidFoodScanDataOnUpdate() {
      let data = request.resource.data;
      return data.userId == resource.data.userId;
    }

    // -------------------------------------------------------------------------
    // Collection Rules
    // -------------------------------------------------------------------------

    /**
     * @description Explicitly denies listing the entire /users collection.
     * @path        /users
     * @allow       (none) - All operations are denied.
     * @deny        A logged-in user attempts `db.collection('users').get()`.
     * @principle   Prevents user enumeration to protect user privacy.
     */
    match /users/{userDoc=**} {
      allow read, write: if false;
    }

    /**
     * @description Secures a user's own profile document.
     * @path        /users/{userId}
     * @allow       (create) A new user signs up and creates their own profile document, `db.collection('users').doc('new_user_uid').set(...)`.
     * @allow       (get, update, delete) The authenticated owner reads or modifies their own profile, `db.collection('users').doc(auth.uid).get()`.
     * @deny        (update) A user tries to modify another user's profile, `db.collection('users').doc('another_user_uid').update(...)`.
     * @deny        (create) A user tries to create a profile document where the document ID does not match their auth UID.
     * @principle   Restricts access to a user's own data tree and enforces self-creation of the root user document.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // A single document cannot be listed.
      allow create: if isOwner(userId) && hasValidUserProfileDataOnCreate(userId);
      allow update: if isExistingOwner(userId) && hasValidUserProfileDataOnUpdate();
      allow delete: if isExistingOwner(userId);

      /**
       * @description Secures a user's collection of food scans.
       * @path        /users/{userId}/foodScans/{foodScanId}
       * @allow       (create, list) The authenticated owner adds a new food scan to their history or lists their past scans.
       * @deny        (get) A user attempts to read a specific food scan belonging to another user.
       * @principle   Enforces document ownership for all items within a user's private subcollection.
       */
      match /foodScans/{foodScanId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && hasValidFoodScanDataOnCreate(userId);
        allow update: if isExistingOwner(userId) && hasValidFoodScanDataOnUpdate();
        allow delete: if isExistingOwner(userId);
      }
    }

    /**
     * @description Defines rules for the publicly readable health conditions data.
     * @path        /healthConditions/{healthConditionId}
     * @allow       (get, list) Any user, authenticated or not, can read the list of health conditions.
     * @deny        (create, update, delete) Any user attempts to modify the master list of health conditions.
     * @principle   Provides public read access for master data while securing writes for admin-only management.
     */
    match /healthConditions/{healthConditionId} {
      allow get: if true;
      allow list: if true;
      // TODO: Implement an admin-check function to allow trusted users to manage this data.
      // Example: `allow write: if isAdmin();`
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Defines rules for the publicly readable food preferences data.
     * @path        /foodPreferences/{foodPreferenceId}
     * @allow       (get, list) Any user, authenticated or not, can read the list of food preferences.
     * @deny        (create, update, delete) Any user attempts to modify the master list of food preferences.
     * @principle   Provides public read access for master data while securing writes for admin-only management.
     */
    match /foodPreferences/{foodPreferenceId} {
      allow get: if true;
      allow list: if true;
      // TODO: Implement an admin-check function to allow trusted users to manage this data.
      // Example: `allow write: if isAdmin();`
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}